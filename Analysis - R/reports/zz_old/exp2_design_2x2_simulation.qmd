---
title: "exp2_design_simulation"
format: html
lang: en-GB
editor: 
  markdown:
    wrap: 62
---

```{r rep parameters}
#| echo: false
save_animations <- FALSE
run_simulations <- FALSE
load_big_data <- TRUE
```

```{r libraries}
#| include: false
library(tidyverse)
library(lsr)
library(pbapply)
library(afex)
library(gt)
library(parallel)
library(gifski)
library(av)
library(gganimate)
```

```{r citations}
#| include: false


```

```{r load data}
#| include: false
load("../../data/processed/exp1_data.rdata") # actual data

load("../../data/simulations/exp2_estimate_effect_500.rdata")
load("../../data/simulations/exp2_gpower_effect_500.rdata")

if(load_big_data){
  # Big sim
  load("../../data/simulations/exp2_simulation_over_effect_sizes_and_sample_sizes.rdata")
  load("../../data/simulations/exp2_simulation_w_postprop_sum.rdata")
}
```

```{r preprocessing}
# preprocess 
source("rep_munge/preprocess.R")
```


# Estimating effect size for ANOVA

## GES 
```{r}
#| echo: false
d_ex |> 
  filter(!is.na(con)) |>
  summarise(
    .by = c(id, con),
    rt = mean(rt),
    pe = 1 - mean(correct_response)
  ) -> d_ex_sum
d_ex_sum |>
  aov_car(rt ~ con + Error(id/con), data = _) |>
  pluck("anova_table") |>
  as_tibble() |>
  mutate( name = "rt", .before = 1) |>
  rbind( 
    d_ex_sum |>
      aov_car(pe ~ con + Error(id/con), data = _) |>
      pluck("anova_table") |>
      as.tibble() |>
      mutate( name = "pe",.before = 1)
    ) -> exp1_anova_outcome
exp1_anova_outcome
```

## Partial eta squared 
```{r}
#| echo: false
#| message: false
d_ex |>
  filter(!is.na(con)) |>
  summarise(
    .by = c(id, con), 
    rt = mean(rt),
    pe = mean(correct_response)) -> anova_test_res
anova_test_res |>
  aov(rt ~ con + Error(id/con), data=_ ) |>
  DescTools::EtaSq(x=_, type=1) |> as_tibble() |>
  mutate(.before = 1, n = "rt") |>
  rbind(
    anova_test_res |>
    aov(pe ~ con + Error(id/con), data=_ ) |>
    DescTools::EtaSq(x=_, type=1) |> 
      as_tibble() |>
      mutate(.before = 1, n = "pe")
  )
```

According to gpower, an effect size of .14 correspond to an effect size of .4:
```{r}
con_eff <- .21
gpow_eff <- .14
```

# Simulating

```{r  on hold? }
exp2_sim2x2 <- function(N, blocks, block.len, post.cue.len, eff.con.pre, eff.con.post, eff.con.cue.intr){
  #' @param N                 Number of subjects
  #' @param blocks            Number of blocks 
  #' @param block.len         Length of each block -- this is split, half the trials are pre and half are post
  #' @param post.cue.len      N of observation after the cue. 
  #' @param eff.con.pre       Effect size of the congruency effect
  #' @param eff.cue.post      Effect size of the pre-post cue
  #' @param eff.con.cue.intr  Effect size of the interaction

  tibble(
    id     = rep(1:N, each = blocks * block.len),
    block  = rep.int( rep(1:blocks, each = block.len), N),
    cue    = rep.int( rep(c("pre", "post"), each = block.len/2), blocks * N),
    con    = rep.int( c("con", "incon"), N * blocks * block.len/2),
    rt     = rnorm(N * blocks * block.len, 
                   0 + 
                     - as.integer(con=="con") * eff.con.pre + 
                     + as.integer(cue=="post") * eff.con.post + 
                     - as.integer(con=="con" & cue=="post") * eff.con.cue.intr,
                   1)
  ) -> d
  
  # Here we remove some post trials equal to half 
  # First we take all the pre trials: 
  d |> 
    filter(cue=="pre") |>
  # Then we combine the filtered post trials: 
  rbind(
    d |> 
      # We filter in such a way that we slice the first trials for each id in each trial:
      filter(cue=="post") |>
      group_by(id, block) |>
      slice_head(n = post.cue.len)
  ) -> test
}
```




# Simulation 2x2 rmANOVA (Congruency X cue)

We can simulate the tests for the experiment by adding an additional factor (cue).
We have two main effects, congruency and cue, including an interaction congruency*cue.
We hypothesize an interaction between the cue and the congruency, while the main effect of congruency will remain weak if existent. 
We do not hypothesize an effect of the cue, but we expect it to interact with the congruency. 
In this way, we expect a congruency effect ONLY for trials AFTER the cue.

In the function below we can generate the experimental setup: 
```{r}
exp2_sim2x2 <- function(N, blocks, block.len, post.cue.len, eff.con.pre, eff.con.post, eff.con.cue.intr){
  #' @param N                 Number of subjects
  #' @param blocks            Number of blocks 
  #' @param block.len         Length of each block -- this is split, half the trials are pre and half are post
  #' @param post.cue.len      N of observation after the cue. 
  #' @param eff.con.pre       Effect size of the congruency effect
  #' @param eff.cue.post      Effect size of the pre-post cue
  #' @param eff.con.cue.intr  Effect size of the interaction

  tibble(
    id     = rep(1:N, each = blocks * block.len),
    block  = rep.int( rep(1:blocks, each = block.len), N),
    cue    = rep.int( rep(c("pre", "post"), each = block.len/2), blocks * N),
    con    = rep.int( c("con", "incon"), N * blocks * block.len/2),
    rt     = rnorm(N * blocks * block.len, 
                   0 + 
                     - as.integer(con=="con") * eff.con.pre + 
                     + as.integer(cue=="post") * eff.con.post + 
                     - as.integer(con=="con" & cue=="post") * eff.con.cue.intr,
                   1)
  ) -> d
  
  # Here we remove some post trials equal to half 
  # First we take all the pre trials: 
  d |> 
    filter(cue=="pre") |>
  # Then we combine the filtered post trials: 
  rbind(
    d |> 
      # We filter in such a way that we slice the first trials for each id in each trial:
      filter(cue=="post") |>
      group_by(id, block) |>
      slice_head(n = post.cue.len)
  ) -> test
}
```

### based on params from diag simu: 

```{r not ran? }

l <- 
list( 
  rt_m  = exp1_outcome$rt_d_m,
  rt_sd = 2,
  pe_m  = exp1_outcome$pe_d_m,
  pe_sd = 7.6
)

if(run_simulations){
  
  makeCluster(detectCores() * .9) -> cl
  clusterExport(cl, c("l", "gen_data"))
  clusterEvalQ(cl, {
    library(tidyverse)
    library(broom)
  })
  
  pblapply(seq(1, 90, 1), \(pairs){
    
    map_df(1:300, \(itr){
      exp2_sim2x2(27, )
      gen_data(27, pairs, l$rt_m, l$rt_sd, l$pe_m, l$pe_sd) |> 
        summarise(
          .by = c(id, con), 
          rt = mean(rt),
          pe = mean(pe)
        ) -> s_d
      
      s_d |>
        pivot_wider(names_from = con, values_from = c(rt,pe)) |>
        summarise(
          rt_m = mean(rt_con-rt_incon),
          rt_sd = sd(rt_con-rt_incon),
          rt_d = rt_m / rt_sd,
          pe_m = mean(pe_con-pe_incon),
          pe_sd = sd(pe_con-pe_incon),
          pe_d = pe_m / pe_sd,
        ) |> 
        cbind(
          t.test(rt ~ con, s_d, paired=T, alternative="greater") |>
            tidy() |> 
            select(2:3) |>
            rename(rt_stat = statistic,
                   rt_p = p.value)
        ) |>
        cbind( 
          t.test(pe ~ con, s_d, paired=T, alternative="greater") |>
            tidy() |> 
            select(2:3) |>
            rename(pe_stat = statistic,
                   pe_p = p.value)
        ) |>
        mutate(
          pairs = pairs,
          itr = itr, 
        ) |>
          select(pairs, itr, starts_with("rt"), starts_with("pe")
        )
    })
    
  }, cl = cl) |> 
    map_df(~.x) -> vary_diagnostic_lengths
  
  stopCluster(cl)
  
  if(save_simulation_data){
    write_parquet(vary_diagnostic_lengths, "../data/simulations/vary_diagnostic_length.parquet")
  }
  
} 
```




### Effect based on estimate
Here we assume the effect as calculated by the one-way ANOVA (.21 post-cue , and .07 pre-cue)

```{r simulate experiment 2}
#| echo: false

if(create_animations){
  
  # Generalized eta squared (effect sizes)
  effect_size_range <- seq(0.04,0.70, 0.02)
  # detectCores()
  proportion_of_cores <- .95 
  
  # Create a "cluster" to simulate faster
  # Take half the computers cores 
  makeCluster( floor(detectCores() * proportion_of_cores) ) -> cl
  # Export the local function
  clusterExport(cl, varlist = c("exp2_sim2x2", "effect_size_range"))
  # Initiate libraries in clusters
  clusterEvalQ(cl, {
    library(tidyverse)
    library(pbapply)
    library(afex)
  })
  
  # Apply function across "cl"
  map_df(10:100, \(sample_size){
    # For each sample size....
    
    pblapply(effect_size_range,\(effect_size){
      # Test all effect sizes... 
      
      map(c(3, 4, 5), \(post_prop){ 
        # Across various post-cue proportions....
        
        map_df(1:300, \(itr_v){
          # And repeat each 300 times ....
            
          d <- 
            exp2_sim2x2(sample_size, 24, 20, 5, effect_size/3, .008, effect_size)
          
          res <-
            d |> 
            aov_car(rt ~ con*cue + Error(id/(con*cue)), data = _, fun_aggregate=mean)
          
          tibble(
            eff     = effect_size,
            size    = sample_size,
            post_prop = post_prop,
            itr     = itr_v,
            name    = c(names(res$Anova$SSP[2]),names(res$Anova$SSP[3]), names(res$Anova$SSP[4])),
            ges     = res[["anova_table"]][["ges"]],
            p       = res[["anova_table"]][["Pr(>F)"]],
          ) |> pivot_wider(names_from = name, values_from = c(ges, p))
          
        })
        
      })
      
    }, cl = cl) |> map_df(~.x)
    
  })  -> exp2_simu_raw_with_postprop
  #save(exp2_simu_raw_with_postprop, file="../data/simulations/exp2_simulation_over_effect_sizes_and_sample_sizes.rdata")
  
  exp2_simu_raw_with_postprop |> 
    summarise(
      pow_con = mean(p_con<.05),
      pow_cue = mean(p_cue<.05),
      pow_con.cue = mean(`p_con:cue`<.05),
      across(c(everything(), -itr), mean),
      .by = c(eff, size, post_prop)
    ) -> exp2_simu_w_post_sum
  
  #save(exp2_simu_w_post_sum, file="../data/simulations/exp2_simulation_w_postprop_sum.rdata")
  
  # stop cluster
  stopCluster(cl)
}
```

```{r power}
#| echo: false

exp2_simu_w_post_sum |> 
  filter(post_prop == 4) |>
  # filter(eff > .4 & eff < .7) |>
  filter(eff < .12 ) |>
  pivot_longer(c(pow_con, pow_cue, pow_con.cue)) |>
  ggplot(aes(size, value, col=factor(eff)))+
  facet_wrap(~name) +
  geom_line(alpha = .4) +
  geom_smooth(alpha = .1) +
  coord_cartesian(ylim=c(.7,1)) + 
  geom_hline(yintercept = .90) +
  geom_vline(xintercept = 36)

```

```{r create animation of effect size increase}
#| echo: false

if(save_animations){
  eff_range <- seq(.04, .24, .02)
  
  walk(seq(.04, .7, .02), \(eff_size){
    
    exp2_simu_w_post_sum |>
      filter( eff %in% eff_size ) |>
      pivot_longer(c(pow_con, pow_cue, pow_con.cue)) |>
      ggplot(aes(size, value, col = factor(post_prop))) +
      facet_wrap(~ name) +
      geom_line(alpha = .4) + 
      geom_smooth(alpha = .1) +
      geom_vline(xintercept = 36) +
      geom_hline(yintercept = .9) +
      coord_cartesian(ylim = c(.7, 1)) +
      labs(col = "post cue", 
           subtitle = paste("Effect size:", eff_size)) -> p
    
    ggsave(paste0("../outputs/animations/exp2_design_2x2/png_over_effs/exp2_design_2x2_eff-", eff_size,".png"), 
           p, 
           width = 10, 
           height = 4)
  })
    
  fignames <- list.files("../outputs/animations/exp2_design_2x2/png_over_effs", full.names = T)
  # create gif
  gifski(fignames, "../outputs/animations/exp2_design_2x2/anim_effect_size_ot.gif", delay = .25)
  # create video format
  av_encode_video(fignames, "../outputs/animations/exp2_design_2x2/anim_effect_size_ot.mkv", framerate = 4)
}
```

```{r create animation of sample size increase}
#| echo: false

if(save_animations){
  walk(10:100, \(samp_size){

    p <-
      exp2_simu_w_post_sum |>
      filter(size == samp_size) |>
      # filter( eff %in% eff_size ) |>
      pivot_longer(c(pow_con, pow_cue, pow_con.cue)) |>
      ggplot(aes(eff, value, col = factor(post_prop))) +
      facet_wrap(~ name) +
      geom_line(alpha = .4) + 
      geom_smooth(alpha = .0) +
      geom_hline(yintercept = .9) +
      geom_vline(xintercept = .21) +
      geom_vline(xintercept = .14, linetype = "dashed") +
      coord_cartesian(ylim = c(.7, 1)) + 
      labs(col = "post cue", 
           subtitle = paste("Sample size:", samp_size)) 
    
    ggsave(paste0("../outputs/animations/exp2_design_2x2/png_over_samp_size/exp2_design_2x2_eff-", samp_size,".png"), 
           p, 
           width = 10, 
           height = 4)
  })
    
  fignames <- 
    tibble(
      fignames = list.files("../outputs/animations/exp2_design_2x2/png_over_samp_size", full.names = T)
    ) |>
    mutate(arr = as.integer(str_split(fignames, "[-.]") |> map_chr(4) ) ) |>
    arrange(arr) |>
    pull(fignames) 
    
  # create gif
  gifski(fignames, "../outputs/animations/exp2_design_2x2/anim_samp_size_over_time.gif", delay = .25, width = 1000)
  # create video format
  av_encode_video(fignames, "../outputs/animations/exp2_design_2x2/anim_samp_size_over_time.mp4", framerate = 4)
}
```

```{r}
#| echo: false

exp
```



